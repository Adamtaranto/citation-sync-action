name: 'Citation Sync Action'
description: 'Automatically synchronize CITATION.cff version and date with Git tags'
author: 'Adamtaranto'
branding:
  icon: 'tag'
  color: 'blue'
inputs:
  token:
    description: 'GitHub token for authentication. Use secrets.GITHUB_TOKEN or a PAT with contents:write permission.'
    required: false
    default: ${{ github.token }}
  citation-path:
    description: 'Path to CITATION.cff file relative to repository root.'
    required: false
    default: 'CITATION.cff'
  target-branch:
    description: 'Branch to push updated CITATION.cff to. If empty, auto-detects default branch.'
    required: false
    default: ''
  update-mode:
    description: 'Update mode: "increment" (default, creates new incremented tag) or "match" (updates to match current tag without increment).'
    required: false
    default: 'increment'
  version-prefix:
    description: 'Expected version tag prefix (e.g., "v", "release-", ""). Empty string for no prefix.'
    required: false
    default: 'v'
  version-format:
    description: 'Expected semantic version format regex. Default validates X.Y.Z format with optional pre-release suffix.'
    required: false
    default: '^([0-9]+)\.([0-9]+)\.([0-9]+)(-[a-zA-Z0-9.-]+)?$'
  enable-debug:
    description: 'Enable debug output for troubleshooting.'
    required: false
    default: 'false'
  commit-message:
    description: 'Template for commit message. Use {version} as placeholder for the new version.'
    required: false
    default: 'chore: Update CITATION.cff to version {version}'
  git-user-name:
    description: 'Git user name for commits.'
    required: false
    default: 'github-actions[bot]'
  git-user-email:
    description: 'Git user email for commits.'
    required: false
    default: 'github-actions[bot]@users.noreply.github.com'
  skip-ci:
    description: 'Add [skip ci] to commit message to prevent triggering CI workflows.'
    required: false
    default: 'true'
  fail-on-conflict:
    description: 'Fail if incremented tag already exists (only applies in increment mode).'
    required: false
    default: 'true'
  validate-cff:
    description: 'Validate CITATION.cff format before and after updates.'
    required: false
    default: 'true'
  use-pull-request:
    description: 'Create a pull request instead of pushing directly to the target branch. Required for protected branches.'
    required: false
    default: 'false'
  pr-branch-prefix:
    description: 'Prefix for pull request branch names (only used when use-pull-request is true).'
    required: false
    default: 'citation-sync-'
  pr-title:
    description: 'Title template for pull request. Use {version} as placeholder (only used when use-pull-request is true).'
    required: false
    default: 'Update CITATION.cff to version {version}'
  pr-body:
    description: 'Body template for pull request. Use {version}, {date}, {original_tag} as placeholders (only used when use-pull-request is true).'
    required: false
    default: 'This PR updates CITATION.cff based on tag {original_tag}.'
outputs:
  needs-update:
    description: 'Whether CITATION.cff needed updating (true/false).'
    value: ${{ steps.check-update.outputs.needs_update }}
  original-tag:
    description: 'The tag that triggered this action.'
    value: ${{ steps.tag-info.outputs.tag_name }}
  new-tag:
    description: 'The new tag created (if update was needed and mode is increment). Empty in match mode.'
    value: ${{ steps.tag-info.outputs.incremented_tag_name }}
  new-version:
    description: 'The new version written to CITATION.cff.'
    value: ${{ steps.tag-info.outputs.new_version }}
  commit-sha:
    description: 'The commit SHA with updated CITATION.cff (if update was needed).'
    value: ${{ steps.commit.outputs.new_commit }}
  target-branch:
    description: 'The branch that was updated (detected or specified).'
    value: ${{ steps.detect-branch.outputs.target_branch }}
  pull-request-number:
    description: 'The pull request number (if use-pull-request is true and update was needed).'
    value: ${{ steps.create-pr.outputs.pr_number }}
  pull-request-url:
    description: 'The pull request URL (if use-pull-request is true and update was needed).'
    value: ${{ steps.create-pr.outputs.pr_url }}
runs:
  using: 'composite'
  steps:
    - name: Validate CITATION.cff exists
      shell: bash
      run: |
        if [ ! -f "${{ inputs.citation-path }}" ]; then
          echo "::error::CITATION.cff file not found at: ${{ inputs.citation-path }}"
          exit 1
        fi
        echo "::notice::Found CITATION.cff at: ${{ inputs.citation-path }}"
    - name: Detect default branch
      id: detect-branch
      shell: bash
      run: |
        if [ -n "${{ inputs.target-branch }}" ]; then
          TARGET_BRANCH="${{ inputs.target-branch }}"
          echo "::notice::Using specified target branch: ${TARGET_BRANCH}"
        else
          # Try git symbolic-ref first (fast, local)
          TARGET_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@') || true

          # Fallback to git remote show origin
          if [ -z "${TARGET_BRANCH}" ]; then
            TARGET_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | sed 's/.*: //') || true
          fi

          # Last resort: use 'main'
          if [ -z "${TARGET_BRANCH}" ]; then
            TARGET_BRANCH="main"
            echo "::warning::Could not detect default branch, using: ${TARGET_BRANCH}"
          else
            echo "::notice::Auto-detected default branch: ${TARGET_BRANCH}"
          fi
        fi

        echo "target_branch=${TARGET_BRANCH}" >> $GITHUB_OUTPUT

        # Verify branch exists
        if ! git rev-parse --verify "refs/remotes/origin/${TARGET_BRANCH}" >/dev/null 2>&1; then
          echo "::error::Target branch '${TARGET_BRANCH}' does not exist"
          exit 1
        fi
    - name: Check branch protection status
      id: check-protection
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        TARGET_BRANCH="${{ steps.detect-branch.outputs.target_branch }}"
        REPO="${{ github.repository }}"
        USE_PR="${{ inputs.use-pull-request }}"

        echo "::group::Checking branch protection status for ${TARGET_BRANCH}"

        # Query GitHub API for branch protection rules
        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/protection.json \
          -H "Authorization: token ${GITHUB_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${REPO}/branches/${TARGET_BRANCH}/protection" 2>/dev/null || echo "000")

        if [ "${HTTP_CODE}" = "200" ]; then
          echo "protected=true" >> $GITHUB_OUTPUT
          echo "::warning::âš ï¸  Branch '${TARGET_BRANCH}' is protected"

          if [ "${USE_PR}" != "true" ]; then
            echo "::error::â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "::error::âŒ BRANCH PROTECTION DETECTED"
            echo "::error::â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "::error::"
            echo "::error::The target branch '${TARGET_BRANCH}' has protection rules enabled."
            echo "::error::This action cannot push directly to protected branches."
            echo "::error::"
            echo "::error::ðŸ”§ SOLUTIONS:"
            echo "::error::"
            echo "::error::1. Enable Pull Request Mode (Recommended):"
            echo "::error::   Add to your workflow:"
            echo "::error::   with:"
            echo "::error::     use-pull-request: true"
            echo "::error::"
            echo "::error::2. Use a different branch without protection:"
            echo "::error::   with:"
            echo "::error::     target-branch: citation-updates"
            echo "::error::"
            echo "::error::3. Use a PAT with admin/bypass permissions:"
            echo "::error::   with:"
            echo "::error::     token: \${{ secrets.ADMIN_PAT }}"
            echo "::error::"
            echo "::error::4. Configure branch protection to allow bypass for this workflow"
            echo "::error::"
            echo "::error::â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            exit 1
          else
            echo "::notice::âœ“ Pull request mode enabled - will create PR instead of direct push"
          fi
        elif [ "${HTTP_CODE}" = "404" ]; then
          echo "protected=false" >> $GITHUB_OUTPUT
          echo "::notice::âœ“ Branch '${TARGET_BRANCH}' is not protected"
        else
          echo "protected=unknown" >> $GITHUB_OUTPUT
          echo "::warning::Unable to determine branch protection status (HTTP ${HTTP_CODE})"
          echo "::warning::Will attempt to push - may fail if branch is protected"
        fi

        echo "::endgroup::"
    - name: Get tag information
      id: tag-info
      shell: bash
      run: |
        # Get the tag name (version)
        TAG_NAME=$(git describe --tags --abbrev=0)
        echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT

        # Get the date of the tag in YYYY-MM-DD format
        TAG_DATE=$(git log -1 --format="%ad" --date=format:%Y-%m-%d "${TAG_NAME}")
        echo "tag_date=${TAG_DATE}" >> $GITHUB_OUTPUT

        # Extract version from tag by removing prefix
        VERSION_PREFIX="${{ inputs.version-prefix }}"
        TAG_VERSION="${TAG_NAME#${VERSION_PREFIX}}"

        # Validate version format
        VERSION_FORMAT="${{ inputs.version-format }}"
        if [[ ! "${TAG_VERSION}" =~ ${VERSION_FORMAT} ]]; then
          echo "::error::Tag '${TAG_NAME}' does not match expected format."
          echo "::error::Expected: prefix='${VERSION_PREFIX}' + version matching '${VERSION_FORMAT}'"
          echo "::error::Got version: '${TAG_VERSION}'"
          echo "::error::Please check your version-prefix and version-format inputs."
          exit 1
        fi

        echo "tag_version=${TAG_VERSION}" >> $GITHUB_OUTPUT

        # Parse major.minor.patch components (ignore pre-release for incrementing)
        if [[ "${TAG_VERSION}" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)(-[a-zA-Z0-9.-]+)?$ ]]; then
          MAJOR="${BASH_REMATCH[1]}"
          MINOR="${BASH_REMATCH[2]}"
          PATCH="${BASH_REMATCH[3]}"
          PRERELEASE="${BASH_REMATCH[4]}"

          # Calculate incremented version (only if in increment mode)
          if [ "${{ inputs.update-mode }}" = "increment" ]; then
            NEW_PATCH=$((PATCH + 1))
            INCREMENTED_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"

            # Create incremented tag name (preserve prefix)
            INCREMENTED_TAG_NAME="${VERSION_PREFIX}${INCREMENTED_VERSION}"

            echo "incremented_version=${INCREMENTED_VERSION}" >> $GITHUB_OUTPUT
            echo "incremented_tag_name=${INCREMENTED_TAG_NAME}" >> $GITHUB_OUTPUT
            echo "::notice::Processing tag: ${TAG_NAME} (version: ${TAG_VERSION}, created on ${TAG_DATE})"
            echo "::notice::If update needed, will create: ${INCREMENTED_TAG_NAME} (version: ${INCREMENTED_VERSION})"
          else
            # Match mode: use current tag version
            echo "new_version=${TAG_VERSION}" >> $GITHUB_OUTPUT
            echo "::notice::Processing tag: ${TAG_NAME} (version: ${TAG_VERSION}, created on ${TAG_DATE})"
            echo "::notice::Match mode: will update CITATION.cff to version ${TAG_VERSION} if needed"
          fi
        else
          echo "::error::Failed to parse semantic version from: ${TAG_VERSION}"
          exit 1
        fi
    - name: Validate CITATION.cff structure (before update)
      shell: bash
      run: |
        CFF_FILE="${{ inputs.citation-path }}"

        # Check YAML syntax
        if ! python3 -c "import yaml; yaml.safe_load(open('${CFF_FILE}'))" 2>/dev/null; then
          echo "::error::Invalid YAML syntax in ${CFF_FILE}"
          exit 1
        fi

        # Check field uniqueness
        VERSION_COUNT=$(grep -c '^version:' "${CFF_FILE}" || echo "0")
        DATE_COUNT=$(grep -c '^date-released:' "${CFF_FILE}" || echo "0")

        if [ "$VERSION_COUNT" -ne 1 ]; then
          echo "::error::CITATION.cff must have exactly one 'version' field (found: ${VERSION_COUNT})"
          exit 1
        fi

        if [ "$DATE_COUNT" -ne 1 ]; then
          echo "::error::CITATION.cff must have exactly one 'date-released' field (found: ${DATE_COUNT})"
          exit 1
        fi

        # Additional validation if enabled
        if [ "${{ inputs.validate-cff }}" = "true" ]; then
          # Check required CFF fields
          for field in cff-version message title authors; do
            if ! grep -q "^${field}:" "${CFF_FILE}"; then
              echo "::error::Missing required CFF field: ${field}"
              exit 1
            fi
          done
        fi

        echo "::notice::CITATION.cff structure validation passed"
    - name: Parse current CITATION.cff
      id: parse-citation
      shell: bash
      run: |
        CFF_FILE="${{ inputs.citation-path }}"

        # Function to safely extract field value
        extract_field() {
          local field=$1
          local file=$2
          grep -E "^${field}:" "${file}" | sed "s/^${field}:[[:space:]]*//" | sed 's/^"//;s/"$//' | head -1
        }

        # Extract current values
        CURRENT_VERSION=$(extract_field "version" "${CFF_FILE}")
        CURRENT_DATE=$(extract_field "date-released" "${CFF_FILE}")

        # Save to outputs
        echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
        echo "current_date=${CURRENT_DATE}" >> $GITHUB_OUTPUT

        # Debug output
        if [ "${{ inputs.enable-debug }}" = "true" ]; then
          echo "::debug::Current version in CITATION.cff: '${CURRENT_VERSION}'"
          echo "::debug::Current date in CITATION.cff: '${CURRENT_DATE}'"
        fi
    - name: Check if update is needed
      id: check-update
      shell: bash
      run: |
        CURRENT_VERSION="${{ steps.parse-citation.outputs.current_version }}"
        CURRENT_DATE="${{ steps.parse-citation.outputs.current_date }}"
        TAG_DATE="${{ steps.tag-info.outputs.tag_date }}"

        # Determine target version based on mode
        if [ "${{ inputs.update-mode }}" = "increment" ]; then
          TARGET_VERSION="${{ steps.tag-info.outputs.incremented_version }}"
          INCREMENTED_TAG_NAME="${{ steps.tag-info.outputs.incremented_tag_name }}"
        else
          TARGET_VERSION="${{ steps.tag-info.outputs.tag_version }}"
        fi

        echo "Comparing values:"
        echo "  Version: '${CURRENT_VERSION}' vs '${TARGET_VERSION}'"
        echo "  Date: '${CURRENT_DATE}' vs '${TAG_DATE}'"

        if [ "${CURRENT_VERSION}" != "${TARGET_VERSION}" ] || [ "${CURRENT_DATE}" != "${TAG_DATE}" ]; then
          # Check if incremented tag already exists (only in increment mode)
          if [ "${{ inputs.update-mode }}" = "increment" ] && [ "${{ inputs.fail-on-conflict }}" = "true" ]; then
            if git rev-parse --verify "refs/tags/${INCREMENTED_TAG_NAME}" >/dev/null 2>&1; then
              echo "::error::Incremented tag ${INCREMENTED_TAG_NAME} already exists!"
              echo "::error::Cannot create new version. Please resolve tag conflicts manually."
              exit 1
            fi
          fi

          echo "needs_update=true" >> $GITHUB_OUTPUT

          if [ "${{ inputs.update-mode }}" = "increment" ]; then
            echo "::notice::CITATION.cff needs updating - will create new version ${TARGET_VERSION}"
          else
            echo "::notice::CITATION.cff needs updating - will update to version ${TARGET_VERSION}"
          fi

          # Create update summary
          UPDATE_SUMMARY=""
          if [ "${CURRENT_VERSION}" != "${TARGET_VERSION}" ]; then
            UPDATE_SUMMARY="${UPDATE_SUMMARY}- Version: ${CURRENT_VERSION} â†’ ${TARGET_VERSION}\n"
          fi
          if [ "${CURRENT_DATE}" != "${TAG_DATE}" ]; then
            UPDATE_SUMMARY="${UPDATE_SUMMARY}- Date: ${CURRENT_DATE} â†’ ${TAG_DATE}\n"
          fi
          echo "update_summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "${UPDATE_SUMMARY}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          echo "needs_update=false" >> $GITHUB_OUTPUT
          echo "::notice::CITATION.cff is already up to date"
        fi
    - name: Update CITATION.cff
      if: steps.check-update.outputs.needs_update == 'true'
      shell: bash
      run: |
        CFF_FILE="${{ inputs.citation-path }}"
        TAG_DATE="${{ steps.tag-info.outputs.tag_date }}"

        # Determine target version
        if [ "${{ inputs.update-mode }}" = "increment" ]; then
          NEW_VERSION="${{ steps.tag-info.outputs.incremented_version }}"
        else
          NEW_VERSION="${{ steps.tag-info.outputs.tag_version }}"
        fi

        # Create a backup
        cp "${CFF_FILE}" "${CFF_FILE}.bak"

        # Function to update or add a field
        update_field() {
          local field=$1
          local value=$2
          local file=$3

          if grep -q "^${field}:" "${file}"; then
            # Field exists, update it (use | as delimiter to avoid issues with / in dates)
            sed -i.tmp "s|^${field}:.*|${field}: ${value}|" "${file}"
            rm -f "${file}.tmp"
            echo "Updated ${field} to: ${value}"
          else
            # Field doesn't exist, add it after cff-version if possible
            if grep -q "^cff-version:" "${file}"; then
              sed -i.tmp "/^cff-version:/a ${field}: ${value}" "${file}"
              rm -f "${file}.tmp"
            else
              # Just append at the end
              echo "${field}: ${value}" >> "${file}"
            fi
            echo "Added ${field}: ${value}"
          fi
        }

        # Update fields
        update_field "version" "${NEW_VERSION}" "${CFF_FILE}"
        update_field "date-released" "${TAG_DATE}" "${CFF_FILE}"

        # Show the diff
        echo "::group::Changes to CITATION.cff"
        diff -u "${CFF_FILE}.bak" "${CFF_FILE}" || true
        echo "::endgroup::"

        # Validate the updated file
        if ! python3 -c "import yaml; yaml.safe_load(open('${CFF_FILE}'))" 2>/dev/null; then
          echo "::error::Update resulted in invalid YAML syntax. Rolling back changes."
          mv "${CFF_FILE}.bak" "${CFF_FILE}"
          echo "::error::Please report this issue - the action may have a bug."
          exit 1
        fi

        # Verify values were updated correctly
        NEW_VERSION_CHECK=$(grep -E '^version:' "${CFF_FILE}" | sed 's/version:[[:space:]]*//' | sed 's/^"//;s/"$//')
        NEW_DATE_CHECK=$(grep -E '^date-released:' "${CFF_FILE}" | sed 's/date-released:[[:space:]]*//' | sed 's/^"//;s/"$//')

        if [ "${NEW_VERSION_CHECK}" != "${NEW_VERSION}" ] || [ "${NEW_DATE_CHECK}" != "${TAG_DATE}" ]; then
          echo "::error::Failed to update CITATION.cff correctly. Rolling back changes."
          echo "Expected version: ${NEW_VERSION}, got: ${NEW_VERSION_CHECK}"
          echo "Expected date: ${TAG_DATE}, got: ${NEW_DATE_CHECK}"
          mv "${CFF_FILE}.bak" "${CFF_FILE}"
          echo "::error::Please report this issue - the action may have a bug."
          exit 1
        fi

        # Remove backup
        rm -f "${CFF_FILE}.bak"
        echo "::notice::Successfully updated CITATION.cff"
    - name: Configure Git
      if: steps.check-update.outputs.needs_update == 'true'
      shell: bash
      run: |
        git config --local user.email "${{ inputs.git-user-email }}"
        git config --local user.name "${{ inputs.git-user-name }}"
    - name: Commit changes
      if: steps.check-update.outputs.needs_update == 'true'
      id: commit
      shell: bash
      run: |
        # Determine version for commit message
        if [ "${{ inputs.update-mode }}" = "increment" ]; then
          NEW_VERSION="${{ steps.tag-info.outputs.incremented_version }}"
        else
          NEW_VERSION="${{ steps.tag-info.outputs.tag_version }}"
        fi

        # Stage the changes
        git add "${{ inputs.citation-path }}"

        # Create commit message
        COMMIT_MSG_TEMPLATE="${{ inputs.commit-message }}"
        COMMIT_MSG="${COMMIT_MSG_TEMPLATE//\{version\}/${NEW_VERSION}}"

        # Add skip ci if enabled
        if [ "${{ inputs.skip-ci }}" = "true" ]; then
          COMMIT_MSG="${COMMIT_MSG}

        [skip ci]"
        fi

        # Create update summary for commit body
        UPDATE_SUMMARY="${{ steps.check-update.outputs.update_summary }}"
        if [ -n "${UPDATE_SUMMARY}" ]; then
          COMMIT_MSG="${COMMIT_MSG}

        ${UPDATE_SUMMARY}"
        fi

        # Commit the changes
        git commit -m "${COMMIT_MSG}"

        # Get the new commit hash
        NEW_COMMIT=$(git rev-parse HEAD)
        echo "new_commit=${NEW_COMMIT}" >> $GITHUB_OUTPUT
        echo "::notice::Created commit ${NEW_COMMIT}"
    - name: Push changes directly (increment mode, direct push)
      if: steps.check-update.outputs.needs_update == 'true' && inputs.update-mode == 'increment' && inputs.use-pull-request != 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        INCREMENTED_TAG_NAME="${{ steps.tag-info.outputs.incremented_tag_name }}"
        INCREMENTED_VERSION="${{ steps.tag-info.outputs.incremented_version }}"
        NEW_COMMIT="${{ steps.commit.outputs.new_commit }}"
        TARGET_BRANCH="${{ steps.detect-branch.outputs.target_branch }}"

        echo "::group::Creating new tag ${INCREMENTED_TAG_NAME} at ${NEW_COMMIT}"

        # Create the new incremented tag at the new commit
        git tag -a "${INCREMENTED_TAG_NAME}" "${NEW_COMMIT}" -m "Release ${INCREMENTED_VERSION}"

        # Push the commit to the target branch
        git push origin "HEAD:${TARGET_BRANCH}" || {
          echo "::error::Failed to push commit to ${TARGET_BRANCH} branch"
          exit 1
        }

        # Push the new tag
        git push origin "${INCREMENTED_TAG_NAME}" || {
          echo "::error::Failed to push new tag"
          exit 1
        }

        echo "::endgroup::"
        echo "::notice::Successfully created new tag ${INCREMENTED_TAG_NAME} at commit ${NEW_COMMIT}"
    - name: Push changes directly (match mode, direct push)
      if: steps.check-update.outputs.needs_update == 'true' && inputs.update-mode == 'match' && inputs.use-pull-request != 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        TARGET_BRANCH="${{ steps.detect-branch.outputs.target_branch }}"
        NEW_COMMIT="${{ steps.commit.outputs.new_commit }}"

        echo "::group::Pushing changes to ${TARGET_BRANCH}"

        # Push the commit to the target branch
        git push origin "HEAD:${TARGET_BRANCH}" || {
          echo "::error::Failed to push commit to ${TARGET_BRANCH} branch"
          exit 1
        }

        echo "::endgroup::"
        echo "::notice::Successfully pushed commit ${NEW_COMMIT} to ${TARGET_BRANCH}"
    - name: Create pull request
      if: steps.check-update.outputs.needs_update == 'true' && inputs.use-pull-request == 'true'
      id: create-pr
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        TARGET_BRANCH="${{ steps.detect-branch.outputs.target_branch }}"
        NEW_COMMIT="${{ steps.commit.outputs.new_commit }}"
        REPO="${{ github.repository }}"

        # Determine version for PR title/body
        if [ "${{ inputs.update-mode }}" = "increment" ]; then
          NEW_VERSION="${{ steps.tag-info.outputs.incremented_version }}"
          INCREMENTED_TAG_NAME="${{ steps.tag-info.outputs.incremented_tag_name }}"
        else
          NEW_VERSION="${{ steps.tag-info.outputs.tag_version }}"
        fi

        ORIGINAL_TAG="${{ steps.tag-info.outputs.tag_name }}"
        TAG_DATE="${{ steps.tag-info.outputs.tag_date }}"

        # Generate PR branch name with timestamp to avoid conflicts
        TIMESTAMP=$(date +%s)
        PR_BRANCH="${{ inputs.pr-branch-prefix }}${NEW_VERSION}-${TIMESTAMP}"

        echo "::group::Creating pull request"
        echo "::notice::PR branch: ${PR_BRANCH}"

        # Push to PR branch
        git push origin "HEAD:${PR_BRANCH}" || {
          echo "::error::Failed to push to PR branch ${PR_BRANCH}"
          exit 1
        }

        # Prepare PR title and body with substitutions
        PR_TITLE="${{ inputs.pr-title }}"
        PR_TITLE="${PR_TITLE//\{version\}/${NEW_VERSION}}"

        PR_BODY="${{ inputs.pr-body }}"
        PR_BODY="${PR_BODY//\{version\}/${NEW_VERSION}}"
        PR_BODY="${PR_BODY//\{date\}/${TAG_DATE}}"
        PR_BODY="${PR_BODY//\{original_tag\}/${ORIGINAL_TAG}}"

        # Add update summary to PR body
        UPDATE_SUMMARY="${{ steps.check-update.outputs.update_summary }}"
        if [ -n "${UPDATE_SUMMARY}" ]; then
          PR_BODY="${PR_BODY}

        ## Changes

        ${UPDATE_SUMMARY}"
        fi

        # Add mode-specific information
        if [ "${{ inputs.update-mode }}" = "increment" ]; then
          PR_BODY="${PR_BODY}

        ## New Tag

        After merging this PR, a new tag \`${INCREMENTED_TAG_NAME}\` will be created."
        fi

        # Create PR using GitHub API
        PR_RESPONSE=$(curl -s -X POST \
          -H "Authorization: token ${GITHUB_TOKEN}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${REPO}/pulls" \
          -d "$(jq -n \
            --arg title "${PR_TITLE}" \
            --arg body "${PR_BODY}" \
            --arg head "${PR_BRANCH}" \
            --arg base "${TARGET_BRANCH}" \
            '{title: $title, body: $body, head: $head, base: $base}')")

        PR_NUMBER=$(echo "${PR_RESPONSE}" | jq -r '.number // empty')
        PR_URL=$(echo "${PR_RESPONSE}" | jq -r '.html_url // empty')

        if [ -z "${PR_NUMBER}" ] || [ "${PR_NUMBER}" = "null" ]; then
          echo "::error::Failed to create pull request"
          echo "::error::Response: ${PR_RESPONSE}"
          exit 1
        fi

        echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
        echo "pr_url=${PR_URL}" >> $GITHUB_OUTPUT
        echo "pr_branch=${PR_BRANCH}" >> $GITHUB_OUTPUT

        echo "::endgroup::"
        echo "::notice::âœ“ Created pull request #${PR_NUMBER}"
        echo "::notice::URL: ${PR_URL}"

        # If increment mode, we need to handle tag creation after PR merge
        # For now, just note this in the PR
        if [ "${{ inputs.update-mode }}" = "increment" ]; then
          echo "::warning::âš ï¸  In increment mode with PR: You must manually create tag ${INCREMENTED_TAG_NAME} after merging the PR"
        fi
    - name: Create job summary
      if: always()
      shell: bash
      run: |
        echo "## CITATION.cff Update Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ "${{ steps.check-update.outputs.needs_update }}" = "true" ]; then
          echo "### âœ… Update Applied" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Update Mode**: ${{ inputs.update-mode }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The following changes were made:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.check-update.outputs.update_summary }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.use-pull-request }}" = "true" ]; then
            echo "**Pull Request**: [#${{ steps.create-pr.outputs.pr_number }}](${{ steps.create-pr.outputs.pr_url }})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "${{ inputs.update-mode }}" = "increment" ]; then
              echo "âš ï¸ **Action Required**: After merging the PR, manually create tag \`${{ steps.tag-info.outputs.incremented_tag_name }}\`" >> $GITHUB_STEP_SUMMARY
            fi
          elif [ "${{ inputs.update-mode }}" = "increment" ]; then
            echo "**New Tag**: \`${{ steps.tag-info.outputs.incremented_tag_name }}\` has been created with the updated CITATION.cff." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Original Tag**: \`${{ steps.tag-info.outputs.tag_name }}\` remains unchanged." >> $GITHUB_STEP_SUMMARY
          else
            echo "**Original Tag**: \`${{ steps.tag-info.outputs.tag_name }}\` triggered the update." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note**: No new tag was created (match mode)." >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "### â„¹ï¸ No Update Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The CITATION.cff file already contains the correct information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.parse-citation.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Date Released**: ${{ steps.parse-citation.outputs.current_date }}" >> $GITHUB_STEP_SUMMARY
        fi

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "*Triggered by tag: \`${{ steps.tag-info.outputs.tag_name }}\`*" >> $GITHUB_STEP_SUMMARY
        echo "*Target branch: \`${{ steps.detect-branch.outputs.target_branch }}\`*" >> $GITHUB_STEP_SUMMARY
